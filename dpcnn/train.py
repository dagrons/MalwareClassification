from dpcnn import DPCNN
from create_data.generate_dataset import generate_train_test

import torch.nn as nn
import torch
import torch.utils.data
import numpy as np


class TrainData(torch.utils.data.Dataset):
	def __init__(self, x_train, y_train):
		self.x = np.asarray(x_train)
		self.y = np.asarray(y_train)

	def __getitem__(self, item):
		x = self.x[item]
		y = self.y[item]

		x = torch.from_numpy(x)

		return x.float(), y

	def __len__(self):
		return len(self.x)


if __name__ == "__main__":
	vec_path = "E:/malware/vec/"
	model_path = "../model/dpcnn.pth"

	x_train, x_test, y_train, y_test = generate_train_test(vec_path)
	criterion = nn.CrossEntropyLoss().cuda()

	model = DPCNN().cuda()

	optimizer = torch.optim.Adam(model.parameters(), lr=1e-4)

	for epoch in range(20):
		print("epoch:", epoch)
		data = TrainData(x_train, y_train)
		train_loader = torch.utils.data.dataloader.DataLoader(data, batch_size=28)
		for i, data in enumerate(train_loader):
			x, y = data

			x = torch.unsqueeze(x, 2).cuda()
			y = torch.unsqueeze(y, 1).cuda()

			x_var = torch.autograd.Variable(x)
			y_var = torch.autograd.Variable(y.long())

			prediction = model(x_var)

			loss = criterion(prediction, y_var)

			optimizer.zero_grad()
			loss.backward()
			optimizer.step()

			print('loss:', loss.item())

	torch.save(model, model_path)
