from create_data.generate_dataset import get_dataset

import torch.nn as nn
import torch
import torch.utils.data
import numpy as np


class TestData(torch.utils.data.Dataset):
	def __init__(self, x_test, y_test):
		self.x = np.asarray(x_test)
		self.y = np.asarray(y_test)

	def __getitem__(self, item):
		x = self.x[item]
		y = self.y[item]

		x = torch.from_numpy(x)

		return x.float(), y

	def __len__(self):
		return len(self.x)


if __name__ == "__main__":
	test_path = "E:/malware/vec/test/"
	model_path = "../model/dpcnn.pth"

	x_test, y_test = get_dataset(test_path)
	criterion = nn.CrossEntropyLoss().cuda()

	model = torch.load(model_path).cuda()

	optimizer = torch.optim.Adam(model.parameters(), lr=1e-4)

	data = TestData(x_test, y_test)
	train_loader = torch.utils.data.dataloader.DataLoader(data, batch_size=28)
	correct = torch.zeros(1).squeeze().cuda()
	total = torch.zeros(1).squeeze().cuda()
	for i, data in enumerate(train_loader):
		x, y = data

		x = torch.unsqueeze(x, 2).cuda()
		y = torch.unsqueeze(y, 1).cuda()

		x_var = torch.autograd.Variable(x)
		y_var = torch.autograd.Variable(y.long())

		output = model(x_var)

		prediction = torch.argmax(output, 1)

		correct += (prediction == y.long()).sum().float()
		total += len(y)

	accuracy = (correct / total).cpu()
	print(accuracy)
