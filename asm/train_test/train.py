from asm.create_data.generate_dataset import get_dataset
from asm.lstm_dpcnn.lstm_dpcnn import LSTM_DPCNN

import torch.nn as nn
import torch
import torch.utils.data


def train_model(name, model_path, epoch):
    """
    Train the specified model.
    :param name: The name of the model (LSTM_DPCNN, DPCNN or LSTM).
    :param model_path: The path to save model.
    :param epoch: Number of iterations to train model.
    :return: Trained model.
    """
    # train_path = input("Please input the path of training data: ")
    train_path = "E:/malware/vec/train"
    if train_path[-1] != '/':
        train_path += '/'

    dataset = get_dataset(train_path)

    criterion = nn.CrossEntropyLoss().cuda()

    if name == "DPCNN":
        from asm.dpcnn.dpcnn import DPCNN
        model = DPCNN().cuda()
    elif name == "LSTM":
        from asm.lstm.lstm import LSTM
        model = LSTM().cuda()
    else:
        model = LSTM_DPCNN().cuda()

    optimizer = torch.optim.Adam(model.parameters(), lr=1e-4)

    for i in range(epoch):
        print("epoch:", i)
        train_loader = torch.utils.data.dataloader.DataLoader(dataset, batch_size=28)
        for j, data in enumerate(train_loader):
            x, y = data

            if name == "LSTM" or name == "LSTM_DPCNN":
                x = torch.unsqueeze(x, 1).cuda()
            else:
                x = torch.unsqueeze(x, 2).cuda()
            y = torch.unsqueeze(y, 1).cuda()

            x_var = torch.autograd.Variable(x)
            y_var = torch.autograd.Variable(y.long())

            prediction = model(x_var)

            loss = criterion(prediction, y_var)

            optimizer.zero_grad()
            loss.backward()
            optimizer.step()

            # print('loss:', loss.item())

    torch.save(model, model_path)
