import re
import torch
import numpy as np
import pandas as pd

from PIL import Image
from gensim.models.doc2vec import Doc2Vec
from torch.nn.functional import softmax
from bytes.create_data.bytes2img import hex2mat


def get_opcode_sequence(file):
    """
    Get opcode sequence from .asm file
    :param file: The name of .asm file
    :return: The opcode sequence
    """
    # Save opcode sequences in string arrays
    opcode_seq = []
    # Use regular expression to get all opcodes and combine opcodes into sequences
    p = re.compile(r'\s([a-fA-F0-9]{2}\s)+\s*([a-z]+)')
    with open(file, errors='ignore') as f:
        for line in f:
            # If a line starts with .text, it is a assembly instruction line
            if line.startswith(".text"):
                m = re.findall(p, line)
                if m:
                    opc = m[0][1]
                    if opc != "align":
                        opcode_seq.append(opc)
    return opcode_seq


def vectorize_asm(file, model_path):
    """
    Vectorize uploaded .asm file.
    :param file: the path of uploaded .asm file
    :param model_path: the path of Doc2Vec model
    :return: 1*256 vector
    """
    model = Doc2Vec.load(model_path)
    vector = model.infer_vector(get_opcode_sequence(file))

    return vector


def predict_file(file, file_type, model):
    """
    Predict uploaded file.
    :param file: the path of uploaded file
    :param file_type: the type of uploaded file (asm/bytes/bmp)
    :return: probability of each category
    """
    probability = []
    if file_type == "asm":
        # get Doc2Vec vector
        vector = vectorize_asm(file, "./display/model/doc2vec.model")
        vector = np.reshape(vector, (1, 1, 256))

        x = torch.from_numpy(vector).cuda()

        model = torch.load("./display/model/lstm_dpcnn.pth").cuda()

        model.eval()
        output = model(x).cpu()
        probability = softmax(output, dim=1)
        probability = probability.detach().numpy()
        probability = np.reshape(probability, 9).tolist()

        for i in range(9):
            if probability[i] < 1e-6:
                probability[i] = 0

    elif file_type == "bytes":
        # get n * width array
        mat = hex2mat(file)
        if mat is None:
            return [1] + [0] * 9

        img = Image.fromarray(mat)
        # convert image to bit map
        img = img.convert("L")
        img = img.resize((224, 224))
        mat = np.asarray(img, dtype=np.float32)
        mat = np.reshape(mat, (1, 1, 224, 224))
        mat = np.repeat(mat, 3, axis=1)
        # get 1*3*256*256 tensor
        x = torch.from_numpy(mat).cuda()

        model.eval()
        output = model(x).cpu()
        probability = softmax(output, dim=1)
        probability = probability.detach().numpy()
        probability = np.reshape(probability, 9).tolist()

        for i in range(9):
            if probability[i] < 1e-6:
                probability[i] = 0

    elif file_type == "bmp":
        image = Image.open(file)
        image = image.resize((224, 224))
        mat = np.asarray(image, dtype=np.float32)
        mat = np.reshape(mat, (1, 1, 224, 224))
        mat = np.repeat(mat, 3, axis=1)
        # get 1*3*256*256 tensor
        x = torch.from_numpy(mat).cuda()

        model = torch.load("./display/model/resnet.pth").cuda()

        model.eval()
        output = model(x).cpu()
        probability = softmax(output, dim=1)
        probability = probability.detach().numpy().tolist()[0]

        for i in range(9):
            if probability[i] < 1e-6:
                probability[i] = 0

    return probability


def read_file_list():
    df = pd.read_csv('file.csv')
    file_list = []
    for i in df['Id']:
        file_list.append(i + ".bytes")
    
    return file_list


model = torch.load("./display/model/resnet.pth").cuda()
result_df = pd.DataFrame(columns=['Id', 'Prediction1', 'Prediction2', 'Prediction3', 'Prediction4', 'Prediction5', 'Prediction6', 'Prediction7', 'Prediction8', 'Prediction9'], index=None)
file_list = read_file_list()
for i in file_list:
    prediction = predict_file("F:/test/" + i, "bytes", model)
    print(prediction)
    new_df = {
        'Id': i[:-6],
        'Prediction1': prediction[0],
        'Prediction2': prediction[1],
        'Prediction3': prediction[2],
        'Prediction4': prediction[3],
        'Prediction5': prediction[4],
        'Prediction6': prediction[5],
        'Prediction7': prediction[6],
        'Prediction8': prediction[7],
        'Prediction9': prediction[8]
    }
    result_df = result_df.append(new_df, ignore_index=True)
result_df.to_csv('result.csv', index=None)
